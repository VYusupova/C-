# TETRIS
## Controls
### Movement
Arrow keys (up, right, down, left)
### Exit
Esc key
## Installation
```git clone XXX && cd frogger```
## Make
```make frogger``` makes switch-case realisation of fsm which you can observe in file src/fsm.c \
```make frogger_fsmtable``` makes fsm realisation based on matrix of pointers on state-control functions which you can observe in file src/fsm_matrix.c

# Спецификация для библиотеки игры из коллекции игр BrickGame

Это задание является первым из серии BrickGame. Всего будет четыре проекта, в каждом — своя игра и свои технологии. Но помимо разработки новых проектов, необходимо будет поддерживать и старые игры, и добавлять поддержку новых игр в старые проекты. ... Для того чтобы поддерживать старые и новые игры, необходимо заранее определиться, как будет устроено АПИ интерфейсов и библиотек, чтобы в дальнейшем не приходилось переписывать уже сданные проекты.

**Игровое поле** представляется, как матрица размерностью 10 на 20. Каждый элемент матрицы соответствует «пикселю» игрового поля и может находиться в одном из двух состояний: пустой и заполненный. Кроме игрового поля, у каждой игры есть дополнительная информация, которая выводится в боковой панели справа от игрового поля. Для дополнительной информации, не используемой во время игры, следует предусмотреть заглушки.

Каждая библиотека с игрой должна иметь функцию, принимающую на вход пользовательский ввод. У консоли имеется восемь физических кнопок: начало игры, пауза, завершение игры, действие и четыре стрелочки.

Функция `userInput` принимает на вход пользовательское действие `action` и дополнительный параметр `hold`, который отвечает за зажатие клавиши.

Функция `updateCurrentState` предназначена для получения данных для отрисовки в интерфейсе. Она возвращает структуру, содержащую информацию о текущем состоянии игры. Например, для тетриса истечение таймера приводит к смещению фигуры вниз на один ряд. Эта функция должна вызываться из интерфейса с некоторой периодичностью для поддержания интерфейса в актуальном состоянии.

```c
typedef enum {
    Start,
    Pause,
    Terminate,
    Left,
    Right,
    Up,
    Down,
    Action
} UserAction_t;

typedef struct {
    int **field;
    int **next;
    int score;
    int high_score;
    int level;
    int speed;
    int pause;
} GameInfo_t;

void userInput(UserAction_t action, bool hold);

GameInfo_t updateCurrentState();
```

Обрати внимание, что информация о текущем состоянии игры `GameInfo_t` может быть представлена внутри библиотеки игры статическим объектом.


## Требования к проекту

### Часть 1. Основное задание

Тебе необходимо реализовать программу BrickGame v1.0 aka Tetris:

- Программа должна быть разработана на языке С стандарта C11 с использованием компилятора gcc.
- Программа должна состоять из двух частей: библиотеки, реализующей логику игры тетрис, и терминального интерфейса с использованием библиотеки `ncurses`.
- Для формализации логики игры должен быть использован конечный автомат.
- Библиотека должна иметь функцию, принимающую на вход ввод пользователя, и функцию, выдающую матрицу, которая описывает текущее состояние игрового поля при каждом ее изменении.
- Код библиотеки программы должен находиться в папке `src/brick_game/tetris`.
- Код с интерфейсом программы должен находиться в папке `src/gui/cli`.
- Сборка программы должна быть настроена с помощью Makefile со стандартным набором целей для **GNU-программ**: all, install, uninstall, clean, dvi, dist, test, gcov_report. Установка должна вестись в любой другой произвольный каталог.
  - [ ] посмотреть makefile утилиты cppcheck

- Программа должна быть разработана в соответствии с принципами структурного программирования.


    

    
<details>
<summary>  7 принципов структурного программирования  </summary>
   
1. Отказ от оператора безусловного перехода goto.
2. Использование трёх базовых управляющих конструкций:
   - Последовательность — однократное выполнение операций в том порядке, в котором они записаны в тексте программы. 
   - Ветвление — однократное выполнение одной из двух или более операций, в зависимости от выполнения заданного условия. 
   - Цикл — многократное исполнение одной и той же операции до тех пор, пока выполняется заданное условие (условие продолжения цикла). 
3. Возможность вложения базовых управляющих конструкций друг в друга произвольным образом
4. Оформление повторяющихся фрагментов программы в виде подпрограмм (процедур и функций). Также в виде подпрограмм можно оформить логически целостные фрагменты программы, даже если они не повторяются
5. Оформление каждой логически законченной группы инструкций как блока. Блоки являются основой структурного программирования
6. Конструкции должны иметь один вход и один выход
7. Разработка программы ведётся пошагово, методом «сверху вниз»  
  _______________________________________________________________________
</details>
    
- При написании кода придерживайся Google Style.
- Должно быть обеспечено покрытие библиотеки unit-тестами с помощью библиотеки `check` (тесты должны проходить на ОС Darwin/Ubuntu). Покрытие библиотеки с логикой игры тестами должно составлять не меньше 80 процентов.
- В игре должны присутствовать следующие механики:  
  [x] Вращение фигур;  
  [x] Перемещение фигуры по горизонтали;  
  - Ускорение падения фигуры (при нажатии кнопки фигура перемещается до конца вниз);  
  [x] Показ следующей фигуры;  
  - Уничтожение заполненных линий;  
  - Завершение игры при достижении верхней границы игрового поля;  
  [x] В игре должны присутствовать все виды фигур, показанные на картинке ниже.  
- Для управления добавь поддержку всех кнопок, предусмотренных на физической консоли:  
  - Начало игры,
  - Пауза,
  - Завершение игры,
  - Стрелка влево — движение фигуры влево,
  - Стрелка вправо — движение фигуры вправо,
  - Стрелка вниз — падение фигуры,
  - Стрелка вверх — не используется в данной игре,
  - Действие (вращение фигуры).
- Игровое поле должно соответствовать размерам игрового поля консоли: 10 «пикселей» в ширину и 20 «пикселей» в высоту.
- Фигура после достижения нижней границы поля или соприкосновения с другой фигурой должна остановиться. Вслед за этим происходит генерация следующей фигуры, показанной на превью.
- Интерфейс библиотеки должен соответствовать описанию, которое находится в materials/library-specification_RUS.md.  
[x] Пользовательский интерфейс должен поддерживать отрисовку игрового поля и дополнительной информации.  
- Подготовь в любом формате диаграмму, описывающую используемый КА (его состояния и все возможные переходы).  

Используемые фигуры:

![Фигуры](misc/images/tetris-pieces.png)

### Часть 2. Дополнительно. Подсчет очков и рекорд в игре

Добавь в игру следующие механики:

- подсчет очков;
- хранение максимального количества очков.

Данная информация должна передаваться и выводиться пользовательским интерфейсом в боковой панели. Максимальное количество очков должно храниться в файле или встраиваемой СУБД и сохраняться между запусками программы.

Максимальное количество очков должно изменяться во время игры, если пользователь превышает текущий показатель максимального количества очков во время игры.

Начисление очков будет происходить следующим образом:

- 1 линия — 100 очков;
- 2 линии — 300 очков;
- 3 линии — 700 очков;
- 4 линии — 1500 очков.

### Часть 3. Дополнительно. Механика уровней

Добавь в игру механику уровней. Каждый раз, когда игрок набирает 600 очков, уровень увеличивается на 1. Повышение уровня увеличивает скорость движения фигур. Максимальное количество уровней — 10.

___

На проекте тебе предстоит пройти код-ревью проверку — не забудь изучить инструкцию для прохождения и проведения код-ревью по [ссылке](https://applicant.21-school.ru/code_review).
